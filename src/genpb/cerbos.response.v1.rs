// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlanResourcesResponse {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub action: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub resource_kind: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub policy_version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub filter: ::core::option::Option<super::super::engine::v1::PlanResourcesFilter>,
    #[prost(message, optional, tag = "6")]
    pub meta: ::core::option::Option<plan_resources_response::Meta>,
    #[prost(message, repeated, tag = "7")]
    pub validation_errors: ::prost::alloc::vec::Vec<
        super::super::schema::v1::ValidationError,
    >,
    #[prost(string, tag = "8")]
    pub cerbos_call_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PlanResourcesResponse`.
pub mod plan_resources_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Meta {
        #[prost(string, tag = "1")]
        pub filter_debug: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub matched_scope: ::prost::alloc::string::String,
    }
}
/// Deprecated. See CheckResourcesResponse.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckResourceSetResponse {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "2")]
    pub resource_instances: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        check_resource_set_response::ActionEffectMap,
    >,
    #[prost(message, optional, tag = "3")]
    pub meta: ::core::option::Option<check_resource_set_response::Meta>,
}
/// Nested message and enum types in `CheckResourceSetResponse`.
pub mod check_resource_set_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ActionEffectMap {
        #[prost(
            map = "string, enumeration(super::super::super::effect::v1::Effect)",
            tag = "1"
        )]
        pub actions: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
        #[prost(message, repeated, tag = "2")]
        pub validation_errors: ::prost::alloc::vec::Vec<
            super::super::super::schema::v1::ValidationError,
        >,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Meta {
        #[prost(map = "string, message", tag = "1")]
        pub resource_instances: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            meta::ActionMeta,
        >,
    }
    /// Nested message and enum types in `Meta`.
    pub mod meta {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct EffectMeta {
            #[prost(string, tag = "1")]
            pub matched_policy: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub matched_scope: ::prost::alloc::string::String,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ActionMeta {
            #[prost(map = "string, message", tag = "1")]
            pub actions: ::std::collections::HashMap<
                ::prost::alloc::string::String,
                EffectMeta,
            >,
            #[prost(string, repeated, tag = "2")]
            pub effective_derived_roles: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
        }
    }
}
/// Deprecated. See CheckResourcesResponse.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckResourceBatchResponse {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<
        check_resource_batch_response::ActionEffectMap,
    >,
}
/// Nested message and enum types in `CheckResourceBatchResponse`.
pub mod check_resource_batch_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ActionEffectMap {
        #[prost(string, tag = "1")]
        pub resource_id: ::prost::alloc::string::String,
        #[prost(
            map = "string, enumeration(super::super::super::effect::v1::Effect)",
            tag = "2"
        )]
        pub actions: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
        #[prost(message, repeated, tag = "3")]
        pub validation_errors: ::prost::alloc::vec::Vec<
            super::super::super::schema::v1::ValidationError,
        >,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckResourcesResponse {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<check_resources_response::ResultEntry>,
    #[prost(string, tag = "3")]
    pub cerbos_call_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CheckResourcesResponse`.
pub mod check_resources_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResultEntry {
        #[prost(message, optional, tag = "1")]
        pub resource: ::core::option::Option<result_entry::Resource>,
        #[prost(
            map = "string, enumeration(super::super::super::effect::v1::Effect)",
            tag = "2"
        )]
        pub actions: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
        #[prost(message, repeated, tag = "3")]
        pub validation_errors: ::prost::alloc::vec::Vec<
            super::super::super::schema::v1::ValidationError,
        >,
        #[prost(message, optional, tag = "4")]
        pub meta: ::core::option::Option<result_entry::Meta>,
        #[prost(message, repeated, tag = "5")]
        pub outputs: ::prost::alloc::vec::Vec<
            super::super::super::engine::v1::OutputEntry,
        >,
    }
    /// Nested message and enum types in `ResultEntry`.
    pub mod result_entry {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Resource {
            #[prost(string, tag = "1")]
            pub id: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub kind: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub policy_version: ::prost::alloc::string::String,
            #[prost(string, tag = "4")]
            pub scope: ::prost::alloc::string::String,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Meta {
            #[prost(map = "string, message", tag = "1")]
            pub actions: ::std::collections::HashMap<
                ::prost::alloc::string::String,
                meta::EffectMeta,
            >,
            #[prost(string, repeated, tag = "2")]
            pub effective_derived_roles: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
        }
        /// Nested message and enum types in `Meta`.
        pub mod meta {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct EffectMeta {
                #[prost(string, tag = "1")]
                pub matched_policy: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub matched_scope: ::prost::alloc::string::String,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlaygroundFailure {
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<playground_failure::Error>,
}
/// Nested message and enum types in `PlaygroundFailure`.
pub mod playground_failure {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ErrorDetails {
        #[prost(uint32, tag = "1")]
        pub line: u32,
        #[prost(uint32, tag = "2")]
        pub column: u32,
        #[prost(string, tag = "3")]
        pub context: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Error {
        #[prost(string, tag = "1")]
        pub file: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub error: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub details: ::core::option::Option<ErrorDetails>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlaygroundValidateResponse {
    #[prost(string, tag = "1")]
    pub playground_id: ::prost::alloc::string::String,
    #[prost(oneof = "playground_validate_response::Outcome", tags = "2, 3")]
    pub outcome: ::core::option::Option<playground_validate_response::Outcome>,
}
/// Nested message and enum types in `PlaygroundValidateResponse`.
pub mod playground_validate_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Outcome {
        #[prost(message, tag = "2")]
        Failure(super::PlaygroundFailure),
        #[prost(message, tag = "3")]
        Success(()),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlaygroundTestResponse {
    #[prost(string, tag = "1")]
    pub playground_id: ::prost::alloc::string::String,
    #[prost(oneof = "playground_test_response::Outcome", tags = "2, 3")]
    pub outcome: ::core::option::Option<playground_test_response::Outcome>,
}
/// Nested message and enum types in `PlaygroundTestResponse`.
pub mod playground_test_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TestResults {
        #[prost(message, optional, tag = "1")]
        pub results: ::core::option::Option<
            super::super::super::policy::v1::TestResults,
        >,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Outcome {
        #[prost(message, tag = "2")]
        Failure(super::PlaygroundFailure),
        #[prost(message, tag = "3")]
        Success(TestResults),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlaygroundEvaluateResponse {
    #[prost(string, tag = "1")]
    pub playground_id: ::prost::alloc::string::String,
    #[prost(oneof = "playground_evaluate_response::Outcome", tags = "2, 3")]
    pub outcome: ::core::option::Option<playground_evaluate_response::Outcome>,
}
/// Nested message and enum types in `PlaygroundEvaluateResponse`.
pub mod playground_evaluate_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EvalResult {
        #[prost(string, tag = "1")]
        pub action: ::prost::alloc::string::String,
        #[prost(enumeration = "super::super::super::effect::v1::Effect", tag = "2")]
        pub effect: i32,
        #[prost(string, tag = "3")]
        pub policy: ::prost::alloc::string::String,
        #[deprecated]
        #[prost(string, repeated, tag = "4")]
        pub effective_derived_roles: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        #[deprecated]
        #[prost(message, repeated, tag = "5")]
        pub validation_errors: ::prost::alloc::vec::Vec<
            super::super::super::schema::v1::ValidationError,
        >,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EvalResultList {
        #[prost(message, repeated, tag = "1")]
        pub results: ::prost::alloc::vec::Vec<EvalResult>,
        #[prost(string, repeated, tag = "2")]
        pub effective_derived_roles: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        #[prost(message, repeated, tag = "3")]
        pub validation_errors: ::prost::alloc::vec::Vec<
            super::super::super::schema::v1::ValidationError,
        >,
        #[prost(message, repeated, tag = "4")]
        pub outputs: ::prost::alloc::vec::Vec<
            super::super::super::engine::v1::OutputEntry,
        >,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Outcome {
        #[prost(message, tag = "2")]
        Failure(super::PlaygroundFailure),
        #[prost(message, tag = "3")]
        Success(EvalResultList),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlaygroundProxyResponse {
    #[prost(string, tag = "1")]
    pub playground_id: ::prost::alloc::string::String,
    #[prost(oneof = "playground_proxy_response::Outcome", tags = "2, 3, 4, 5, 6")]
    pub outcome: ::core::option::Option<playground_proxy_response::Outcome>,
}
/// Nested message and enum types in `PlaygroundProxyResponse`.
pub mod playground_proxy_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Outcome {
        #[prost(message, tag = "2")]
        Failure(super::PlaygroundFailure),
        #[prost(message, tag = "3")]
        CheckResourceSet(super::CheckResourceSetResponse),
        #[prost(message, tag = "4")]
        CheckResourceBatch(super::CheckResourceBatchResponse),
        #[prost(message, tag = "5")]
        PlanResources(super::PlanResourcesResponse),
        #[prost(message, tag = "6")]
        CheckResources(super::CheckResourcesResponse),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddOrUpdatePolicyResponse {
    #[prost(message, optional, tag = "1")]
    pub success: ::core::option::Option<()>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAuditLogEntriesResponse {
    #[prost(oneof = "list_audit_log_entries_response::Entry", tags = "1, 2")]
    pub entry: ::core::option::Option<list_audit_log_entries_response::Entry>,
}
/// Nested message and enum types in `ListAuditLogEntriesResponse`.
pub mod list_audit_log_entries_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Entry {
        #[prost(message, tag = "1")]
        AccessLogEntry(super::super::super::audit::v1::AccessLogEntry),
        #[prost(message, tag = "2")]
        DecisionLogEntry(super::super::super::audit::v1::DecisionLogEntry),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerInfoResponse {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub commit: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub build_date: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPoliciesResponse {
    #[prost(string, repeated, tag = "1")]
    pub policy_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPolicyResponse {
    #[prost(message, repeated, tag = "1")]
    pub policies: ::prost::alloc::vec::Vec<super::super::policy::v1::Policy>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisablePolicyResponse {
    #[prost(uint32, tag = "1")]
    pub disabled_policies: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnablePolicyResponse {
    #[prost(uint32, tag = "1")]
    pub enabled_policies: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InspectPoliciesResponse {
    #[prost(map = "string, message", tag = "1")]
    pub results: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        inspect_policies_response::Result,
    >,
}
/// Nested message and enum types in `InspectPoliciesResponse`.
pub mod inspect_policies_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Attribute {
        #[prost(enumeration = "attribute::Kind", tag = "1")]
        pub kind: i32,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `Attribute`.
    pub mod attribute {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Kind {
            Unspecified = 0,
            PrincipalAttribute = 1,
            ResourceAttribute = 2,
        }
        impl Kind {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "KIND_UNSPECIFIED",
                    Self::PrincipalAttribute => "KIND_PRINCIPAL_ATTRIBUTE",
                    Self::ResourceAttribute => "KIND_RESOURCE_ATTRIBUTE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "KIND_UNSPECIFIED" => Some(Self::Unspecified),
                    "KIND_PRINCIPAL_ATTRIBUTE" => Some(Self::PrincipalAttribute),
                    "KIND_RESOURCE_ATTRIBUTE" => Some(Self::ResourceAttribute),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DerivedRole {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(enumeration = "derived_role::Kind", tag = "2")]
        pub kind: i32,
        #[prost(string, tag = "3")]
        pub source: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `DerivedRole`.
    pub mod derived_role {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Kind {
            Unspecified = 0,
            Undefined = 1,
            Exported = 2,
            Imported = 3,
        }
        impl Kind {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "KIND_UNSPECIFIED",
                    Self::Undefined => "KIND_UNDEFINED",
                    Self::Exported => "KIND_EXPORTED",
                    Self::Imported => "KIND_IMPORTED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "KIND_UNSPECIFIED" => Some(Self::Unspecified),
                    "KIND_UNDEFINED" => Some(Self::Undefined),
                    "KIND_EXPORTED" => Some(Self::Exported),
                    "KIND_IMPORTED" => Some(Self::Imported),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Variable {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
        #[prost(enumeration = "variable::Kind", tag = "3")]
        pub kind: i32,
        #[prost(string, tag = "4")]
        pub source: ::prost::alloc::string::String,
        #[prost(bool, tag = "5")]
        pub used: bool,
    }
    /// Nested message and enum types in `Variable`.
    pub mod variable {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Kind {
            Unspecified = 0,
            Exported = 1,
            Imported = 2,
            Local = 3,
            Undefined = 4,
            Unknown = 5,
        }
        impl Kind {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "KIND_UNSPECIFIED",
                    Self::Exported => "KIND_EXPORTED",
                    Self::Imported => "KIND_IMPORTED",
                    Self::Local => "KIND_LOCAL",
                    Self::Undefined => "KIND_UNDEFINED",
                    Self::Unknown => "KIND_UNKNOWN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "KIND_UNSPECIFIED" => Some(Self::Unspecified),
                    "KIND_EXPORTED" => Some(Self::Exported),
                    "KIND_IMPORTED" => Some(Self::Imported),
                    "KIND_LOCAL" => Some(Self::Local),
                    "KIND_UNDEFINED" => Some(Self::Undefined),
                    "KIND_UNKNOWN" => Some(Self::Unknown),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Result {
        #[prost(string, repeated, tag = "1")]
        pub actions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "2")]
        pub variables: ::prost::alloc::vec::Vec<Variable>,
        #[prost(string, tag = "3")]
        pub policy_id: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "4")]
        pub derived_roles: ::prost::alloc::vec::Vec<DerivedRole>,
        #[prost(message, repeated, tag = "5")]
        pub attributes: ::prost::alloc::vec::Vec<Attribute>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddOrUpdateSchemaResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchemasResponse {
    #[prost(string, repeated, tag = "1")]
    pub schema_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSchemaResponse {
    #[prost(message, repeated, tag = "1")]
    pub schemas: ::prost::alloc::vec::Vec<super::super::schema::v1::Schema>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteSchemaResponse {
    #[prost(uint32, tag = "1")]
    pub deleted_schemas: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReloadStoreResponse {}
