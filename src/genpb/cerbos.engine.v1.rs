// This file is @generated by prost-build.
#[cfg_attr(
    feature = "serde",
    derive(serde::Deserialize),
    serde(rename_all = "camelCase")
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlanResourcesInput {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(string, tag = "2")]
    pub action: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "7")]
    pub actions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub principal: ::core::option::Option<Principal>,
    #[prost(message, optional, tag = "4")]
    pub resource: ::core::option::Option<plan_resources_input::Resource>,
    #[prost(message, optional, tag = "5")]
    pub aux_data: ::core::option::Option<AuxData>,
    #[prost(bool, tag = "6")]
    pub include_meta: bool,
}
/// Nested message and enum types in `PlanResourcesInput`.
pub mod plan_resources_input {
    #[cfg_attr(
        feature = "serde",
        derive(serde::Deserialize),
        serde(rename_all = "camelCase")
    )]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Resource {
        #[prost(string, tag = "1")]
        pub kind: ::prost::alloc::string::String,
        #[prost(map = "string, message", tag = "2")]
        pub attr: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            super::super::super::super::google::protobuf::Value,
        >,
        #[prost(string, tag = "3")]
        pub policy_version: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub scope: ::prost::alloc::string::String,
    }
}
#[cfg_attr(
    feature = "serde",
    derive(serde::Deserialize),
    serde(rename_all = "camelCase")
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlanResourcesAst {
    #[prost(message, optional, tag = "1")]
    pub filter_ast: ::core::option::Option<plan_resources_ast::Node>,
}
/// Nested message and enum types in `PlanResourcesAst`.
pub mod plan_resources_ast {
    #[cfg_attr(
        feature = "serde",
        derive(serde::Deserialize),
        serde(rename_all = "camelCase")
    )]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Node {
        #[prost(oneof = "node::Node", tags = "1, 2")]
        pub node: ::core::option::Option<node::Node>,
    }
    /// Nested message and enum types in `Node`.
    pub mod node {
        #[cfg_attr(
            feature = "serde",
            derive(serde::Deserialize),
            serde(rename_all = "camelCase")
        )]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Node {
            #[prost(message, tag = "1")]
            LogicalOperation(super::LogicalOperation),
            #[prost(message, tag = "2")]
            Expression(
                super::super::super::super::super::google::api::expr::v1alpha1::CheckedExpr,
            ),
        }
    }
    #[cfg_attr(
        feature = "serde",
        derive(serde::Deserialize),
        serde(rename_all = "camelCase")
    )]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LogicalOperation {
        #[prost(enumeration = "logical_operation::Operator", tag = "1")]
        pub operator: i32,
        #[prost(message, repeated, tag = "2")]
        pub nodes: ::prost::alloc::vec::Vec<Node>,
    }
    /// Nested message and enum types in `LogicalOperation`.
    pub mod logical_operation {
        #[cfg_attr(
            feature = "serde",
            derive(serde::Deserialize),
            serde(rename_all = "camelCase")
        )]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Operator {
            Unspecified = 0,
            And = 1,
            Or = 2,
            Not = 3,
        }
        impl Operator {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "OPERATOR_UNSPECIFIED",
                    Self::And => "OPERATOR_AND",
                    Self::Or => "OPERATOR_OR",
                    Self::Not => "OPERATOR_NOT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                    "OPERATOR_AND" => Some(Self::And),
                    "OPERATOR_OR" => Some(Self::Or),
                    "OPERATOR_NOT" => Some(Self::Not),
                    _ => None,
                }
            }
        }
    }
}
#[cfg_attr(
    feature = "serde",
    derive(serde::Deserialize),
    serde(rename_all = "camelCase")
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlanResourcesFilter {
    #[prost(enumeration = "plan_resources_filter::Kind", tag = "1")]
    pub kind: i32,
    #[prost(message, optional, tag = "2")]
    pub condition: ::core::option::Option<plan_resources_filter::expression::Operand>,
}
/// Nested message and enum types in `PlanResourcesFilter`.
pub mod plan_resources_filter {
    #[cfg_attr(
        feature = "serde",
        derive(serde::Deserialize),
        serde(rename_all = "camelCase")
    )]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Expression {
        #[prost(string, tag = "1")]
        pub operator: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub operands: ::prost::alloc::vec::Vec<expression::Operand>,
    }
    /// Nested message and enum types in `Expression`.
    pub mod expression {
        #[cfg_attr(
            feature = "serde",
            derive(serde::Deserialize),
            serde(rename_all = "camelCase")
        )]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Operand {
            #[prost(oneof = "operand::Node", tags = "1, 2, 3")]
            pub node: ::core::option::Option<operand::Node>,
        }
        /// Nested message and enum types in `Operand`.
        pub mod operand {
            #[cfg_attr(
                feature = "serde",
                derive(serde::Deserialize),
                serde(rename_all = "camelCase")
            )]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Node {
                #[prost(message, tag = "1")]
                Value(super::super::super::super::super::super::google::protobuf::Value),
                #[prost(message, tag = "2")]
                Expression(super::super::Expression),
                #[prost(string, tag = "3")]
                Variable(::prost::alloc::string::String),
            }
        }
    }
    #[cfg_attr(
        feature = "serde",
        derive(serde::Deserialize),
        serde(rename_all = "camelCase")
    )]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        Unspecified = 0,
        AlwaysAllowed = 1,
        AlwaysDenied = 2,
        Conditional = 3,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "KIND_UNSPECIFIED",
                Self::AlwaysAllowed => "KIND_ALWAYS_ALLOWED",
                Self::AlwaysDenied => "KIND_ALWAYS_DENIED",
                Self::Conditional => "KIND_CONDITIONAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KIND_UNSPECIFIED" => Some(Self::Unspecified),
                "KIND_ALWAYS_ALLOWED" => Some(Self::AlwaysAllowed),
                "KIND_ALWAYS_DENIED" => Some(Self::AlwaysDenied),
                "KIND_CONDITIONAL" => Some(Self::Conditional),
                _ => None,
            }
        }
    }
}
#[cfg_attr(
    feature = "serde",
    derive(serde::Deserialize),
    serde(rename_all = "camelCase")
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlanResourcesOutput {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(string, tag = "2")]
    pub action: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub policy_version: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub scope: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub filter: ::core::option::Option<PlanResourcesFilter>,
    #[prost(string, tag = "7")]
    pub filter_debug: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "8")]
    pub validation_errors: ::prost::alloc::vec::Vec<
        super::super::schema::v1::ValidationError,
    >,
    #[prost(string, repeated, tag = "9")]
    pub actions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "10")]
    pub matched_scopes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[cfg_attr(
    feature = "serde",
    derive(serde::Deserialize),
    serde(rename_all = "camelCase")
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckInput {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<Resource>,
    #[prost(message, optional, tag = "3")]
    pub principal: ::core::option::Option<Principal>,
    #[prost(string, repeated, tag = "4")]
    pub actions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub aux_data: ::core::option::Option<AuxData>,
}
#[cfg_attr(
    feature = "serde",
    derive(serde::Deserialize),
    serde(rename_all = "camelCase")
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckOutput {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub resource_id: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "3")]
    pub actions: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        check_output::ActionEffect,
    >,
    #[prost(string, repeated, tag = "4")]
    pub effective_derived_roles: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "5")]
    pub validation_errors: ::prost::alloc::vec::Vec<
        super::super::schema::v1::ValidationError,
    >,
    #[prost(message, repeated, tag = "6")]
    pub outputs: ::prost::alloc::vec::Vec<OutputEntry>,
}
/// Nested message and enum types in `CheckOutput`.
pub mod check_output {
    #[cfg_attr(
        feature = "serde",
        derive(serde::Deserialize),
        serde(rename_all = "camelCase")
    )]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ActionEffect {
        #[prost(enumeration = "super::super::super::effect::v1::Effect", tag = "1")]
        pub effect: i32,
        #[prost(string, tag = "2")]
        pub policy: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub scope: ::prost::alloc::string::String,
    }
}
#[cfg_attr(
    feature = "serde",
    derive(serde::Deserialize),
    serde(rename_all = "camelCase")
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputEntry {
    #[prost(string, tag = "1")]
    pub src: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub val: ::core::option::Option<super::super::super::google::protobuf::Value>,
}
#[cfg_attr(
    feature = "serde",
    derive(serde::Deserialize),
    serde(rename_all = "camelCase")
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Resource {
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub policy_version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "4")]
    pub attr: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::super::super::google::protobuf::Value,
    >,
    #[prost(string, tag = "5")]
    pub scope: ::prost::alloc::string::String,
}
#[cfg_attr(
    feature = "serde",
    derive(serde::Deserialize),
    serde(rename_all = "camelCase")
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Principal {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub policy_version: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub roles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "4")]
    pub attr: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::super::super::google::protobuf::Value,
    >,
    #[prost(string, tag = "5")]
    pub scope: ::prost::alloc::string::String,
}
#[cfg_attr(
    feature = "serde",
    derive(serde::Deserialize),
    serde(rename_all = "camelCase")
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuxData {
    #[prost(map = "string, message", tag = "1")]
    pub jwt: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::super::super::google::protobuf::Value,
    >,
}
#[cfg_attr(
    feature = "serde",
    derive(serde::Deserialize),
    serde(rename_all = "camelCase")
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Trace {
    #[prost(message, repeated, tag = "1")]
    pub components: ::prost::alloc::vec::Vec<trace::Component>,
    #[prost(message, optional, tag = "2")]
    pub event: ::core::option::Option<trace::Event>,
}
/// Nested message and enum types in `Trace`.
pub mod trace {
    #[cfg_attr(
        feature = "serde",
        derive(serde::Deserialize),
        serde(rename_all = "camelCase")
    )]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Component {
        #[prost(enumeration = "component::Kind", tag = "1")]
        pub kind: i32,
        #[prost(
            oneof = "component::Details",
            tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13"
        )]
        pub details: ::core::option::Option<component::Details>,
    }
    /// Nested message and enum types in `Component`.
    pub mod component {
        #[cfg_attr(
            feature = "serde",
            derive(serde::Deserialize),
            serde(rename_all = "camelCase")
        )]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Variable {
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub expr: ::prost::alloc::string::String,
        }
        #[cfg_attr(
            feature = "serde",
            derive(serde::Deserialize),
            serde(rename_all = "camelCase")
        )]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Kind {
            Unspecified = 0,
            Action = 1,
            ConditionAll = 2,
            ConditionAny = 3,
            ConditionNone = 4,
            Condition = 5,
            DerivedRole = 6,
            Expr = 7,
            Policy = 8,
            Resource = 9,
            Rule = 10,
            Scope = 11,
            Variable = 12,
            Variables = 13,
            Output = 14,
            RolePolicyScope = 15,
            Role = 16,
        }
        impl Kind {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "KIND_UNSPECIFIED",
                    Self::Action => "KIND_ACTION",
                    Self::ConditionAll => "KIND_CONDITION_ALL",
                    Self::ConditionAny => "KIND_CONDITION_ANY",
                    Self::ConditionNone => "KIND_CONDITION_NONE",
                    Self::Condition => "KIND_CONDITION",
                    Self::DerivedRole => "KIND_DERIVED_ROLE",
                    Self::Expr => "KIND_EXPR",
                    Self::Policy => "KIND_POLICY",
                    Self::Resource => "KIND_RESOURCE",
                    Self::Rule => "KIND_RULE",
                    Self::Scope => "KIND_SCOPE",
                    Self::Variable => "KIND_VARIABLE",
                    Self::Variables => "KIND_VARIABLES",
                    Self::Output => "KIND_OUTPUT",
                    Self::RolePolicyScope => "KIND_ROLE_POLICY_SCOPE",
                    Self::Role => "KIND_ROLE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "KIND_UNSPECIFIED" => Some(Self::Unspecified),
                    "KIND_ACTION" => Some(Self::Action),
                    "KIND_CONDITION_ALL" => Some(Self::ConditionAll),
                    "KIND_CONDITION_ANY" => Some(Self::ConditionAny),
                    "KIND_CONDITION_NONE" => Some(Self::ConditionNone),
                    "KIND_CONDITION" => Some(Self::Condition),
                    "KIND_DERIVED_ROLE" => Some(Self::DerivedRole),
                    "KIND_EXPR" => Some(Self::Expr),
                    "KIND_POLICY" => Some(Self::Policy),
                    "KIND_RESOURCE" => Some(Self::Resource),
                    "KIND_RULE" => Some(Self::Rule),
                    "KIND_SCOPE" => Some(Self::Scope),
                    "KIND_VARIABLE" => Some(Self::Variable),
                    "KIND_VARIABLES" => Some(Self::Variables),
                    "KIND_OUTPUT" => Some(Self::Output),
                    "KIND_ROLE_POLICY_SCOPE" => Some(Self::RolePolicyScope),
                    "KIND_ROLE" => Some(Self::Role),
                    _ => None,
                }
            }
        }
        #[cfg_attr(
            feature = "serde",
            derive(serde::Deserialize),
            serde(rename_all = "camelCase")
        )]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Details {
            #[prost(string, tag = "2")]
            Action(::prost::alloc::string::String),
            #[prost(string, tag = "3")]
            DerivedRole(::prost::alloc::string::String),
            #[prost(string, tag = "4")]
            Expr(::prost::alloc::string::String),
            #[prost(uint32, tag = "5")]
            Index(u32),
            #[prost(string, tag = "6")]
            Policy(::prost::alloc::string::String),
            #[prost(string, tag = "7")]
            Resource(::prost::alloc::string::String),
            #[prost(string, tag = "8")]
            Rule(::prost::alloc::string::String),
            #[prost(string, tag = "9")]
            Scope(::prost::alloc::string::String),
            #[prost(message, tag = "10")]
            Variable(Variable),
            #[prost(string, tag = "11")]
            Output(::prost::alloc::string::String),
            #[prost(string, tag = "12")]
            RolePolicyScope(::prost::alloc::string::String),
            #[prost(string, tag = "13")]
            Role(::prost::alloc::string::String),
        }
    }
    #[cfg_attr(
        feature = "serde",
        derive(serde::Deserialize),
        serde(rename_all = "camelCase")
    )]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Event {
        #[prost(enumeration = "event::Status", tag = "1")]
        pub status: i32,
        #[prost(enumeration = "super::super::super::effect::v1::Effect", tag = "2")]
        pub effect: i32,
        #[prost(string, tag = "3")]
        pub error: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub message: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "5")]
        pub result: ::core::option::Option<
            super::super::super::super::google::protobuf::Value,
        >,
    }
    /// Nested message and enum types in `Event`.
    pub mod event {
        #[cfg_attr(
            feature = "serde",
            derive(serde::Deserialize),
            serde(rename_all = "camelCase")
        )]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Status {
            Unspecified = 0,
            Activated = 1,
            Skipped = 2,
        }
        impl Status {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATUS_UNSPECIFIED",
                    Self::Activated => "STATUS_ACTIVATED",
                    Self::Skipped => "STATUS_SKIPPED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                    "STATUS_ACTIVATED" => Some(Self::Activated),
                    "STATUS_SKIPPED" => Some(Self::Skipped),
                    _ => None,
                }
            }
        }
    }
}
/// Data from the request, provided to expressions as the top-level `request` variable.
#[cfg_attr(
    feature = "serde",
    derive(serde::Deserialize),
    serde(rename_all = "camelCase")
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Request {
    #[prost(message, optional, tag = "1")]
    pub principal: ::core::option::Option<request::Principal>,
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<request::Resource>,
    #[prost(message, optional, tag = "3")]
    pub aux_data: ::core::option::Option<AuxData>,
}
/// Nested message and enum types in `Request`.
pub mod request {
    #[cfg_attr(
        feature = "serde",
        derive(serde::Deserialize),
        serde(rename_all = "camelCase")
    )]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Principal {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "2")]
        pub roles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(map = "string, message", tag = "3")]
        pub attr: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            super::super::super::super::google::protobuf::Value,
        >,
        #[prost(string, tag = "4")]
        pub policy_version: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub scope: ::prost::alloc::string::String,
    }
    #[cfg_attr(
        feature = "serde",
        derive(serde::Deserialize),
        serde(rename_all = "camelCase")
    )]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Resource {
        #[prost(string, tag = "1")]
        pub kind: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub id: ::prost::alloc::string::String,
        #[prost(map = "string, message", tag = "3")]
        pub attr: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            super::super::super::super::google::protobuf::Value,
        >,
        #[prost(string, tag = "4")]
        pub policy_version: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub scope: ::prost::alloc::string::String,
    }
}
/// Data from the runtime, provided to expressions as the top-level `runtime` variable.
#[cfg_attr(
    feature = "serde",
    derive(serde::Deserialize),
    serde(rename_all = "camelCase")
)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Runtime {
    #[prost(string, repeated, tag = "1")]
    pub effective_derived_roles: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
